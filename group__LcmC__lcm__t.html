<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>LCM: lcm_t</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LCM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lcm_t<div class="ingroups"><a class="el" href="group__LcmC.html">C API Reference</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Publish and receive messages.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__lcm__recv__buf__t.html">lcm_recv_buf_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6b4e59ecfa218a2be217b3e3e57dce6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b4e59ecfa218a2be217b3e3e57dce6f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LcmC__lcm__t.html#ga6b4e59ecfa218a2be217b3e3e57dce6f">LCM_MAJOR_VERSION</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga6b4e59ecfa218a2be217b3e3e57dce6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">LCM release major version - the X in version X.Y.Z. <br /></td></tr>
<tr class="separator:ga6b4e59ecfa218a2be217b3e3e57dce6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23ab90805080f368a1be54ef9fb56e1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga23ab90805080f368a1be54ef9fb56e1c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LcmC__lcm__t.html#ga23ab90805080f368a1be54ef9fb56e1c">LCM_MINOR_VERSION</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:ga23ab90805080f368a1be54ef9fb56e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LCM release minor version - the Y in version X.Y.Z. <br /></td></tr>
<tr class="separator:ga23ab90805080f368a1be54ef9fb56e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c3ab63e14ba96849a21a518d9142e97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7c3ab63e14ba96849a21a518d9142e97"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LcmC__lcm__t.html#ga7c3ab63e14ba96849a21a518d9142e97">LCM_MICRO_VERSION</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga7c3ab63e14ba96849a21a518d9142e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">LCM release micro version - the Z in version X.Y.Z. <br /></td></tr>
<tr class="separator:ga7c3ab63e14ba96849a21a518d9142e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gabb730c9e49442a4bcf400e0f2fef7576"><td class="memItemLeft" align="right" valign="top">typedef struct _lcm_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a></td></tr>
<tr class="separator:gabb730c9e49442a4bcf400e0f2fef7576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3149702f5022ed075e7aacb3bc261d00"><td class="memItemLeft" align="right" valign="top">typedef struct _lcm_subscription_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LcmC__lcm__t.html#ga3149702f5022ed075e7aacb3bc261d00">lcm_subscription_t</a></td></tr>
<tr class="separator:ga3149702f5022ed075e7aacb3bc261d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cedfd752d27dc39c8ee0836993a3e53"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LcmC__lcm__t.html#ga2cedfd752d27dc39c8ee0836993a3e53">lcm_msg_handler_t</a>) (const lcm_recv_buf_t *rbuf, const char *channel, void *user_data)</td></tr>
<tr class="memdesc:ga2cedfd752d27dc39c8ee0836993a3e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function prototype.  <a href="#ga2cedfd752d27dc39c8ee0836993a3e53">More...</a><br /></td></tr>
<tr class="separator:ga2cedfd752d27dc39c8ee0836993a3e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf29963ef43edadf45296d5ad82c18d4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LcmC__lcm__t.html#gaf29963ef43edadf45296d5ad82c18d4b">lcm_create</a> (const char *provider)</td></tr>
<tr class="memdesc:gaf29963ef43edadf45296d5ad82c18d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#gaf29963ef43edadf45296d5ad82c18d4b">More...</a><br /></td></tr>
<tr class="separator:gaf29963ef43edadf45296d5ad82c18d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c86753e2e8c535bc8fb91d3763336e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4c86753e2e8c535bc8fb91d3763336e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LcmC__lcm__t.html#ga4c86753e2e8c535bc8fb91d3763336e2">lcm_destroy</a> (<a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *lcm)</td></tr>
<tr class="memdesc:ga4c86753e2e8c535bc8fb91d3763336e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ga4c86753e2e8c535bc8fb91d3763336e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51bd65da2efbd1ef094cb36b4a906922"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LcmC__lcm__t.html#ga51bd65da2efbd1ef094cb36b4a906922">lcm_get_fileno</a> (<a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *lcm)</td></tr>
<tr class="memdesc:ga51bd65da2efbd1ef094cb36b4a906922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a file descriptor or socket that can be used with <code>select()</code>, <code>poll()</code>, or other event loops for asynchronous notification of incoming messages.  <a href="#ga51bd65da2efbd1ef094cb36b4a906922">More...</a><br /></td></tr>
<tr class="separator:ga51bd65da2efbd1ef094cb36b4a906922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c8521ce6e87cbbeb7bfd935d5c0d724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__LcmC__lcm__t.html#ga3149702f5022ed075e7aacb3bc261d00">lcm_subscription_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LcmC__lcm__t.html#ga1c8521ce6e87cbbeb7bfd935d5c0d724">lcm_subscribe</a> (<a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *lcm, const char *channel, <a class="el" href="group__LcmC__lcm__t.html#ga2cedfd752d27dc39c8ee0836993a3e53">lcm_msg_handler_t</a> handler, void *userdata)</td></tr>
<tr class="memdesc:ga1c8521ce6e87cbbeb7bfd935d5c0d724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe a callback function to a channel, without automatic message decoding.  <a href="#ga1c8521ce6e87cbbeb7bfd935d5c0d724">More...</a><br /></td></tr>
<tr class="separator:ga1c8521ce6e87cbbeb7bfd935d5c0d724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga920fac8964a733d575dc83e7050c9287"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LcmC__lcm__t.html#ga920fac8964a733d575dc83e7050c9287">lcm_unsubscribe</a> (<a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *lcm, <a class="el" href="group__LcmC__lcm__t.html#ga3149702f5022ed075e7aacb3bc261d00">lcm_subscription_t</a> *handler)</td></tr>
<tr class="memdesc:ga920fac8964a733d575dc83e7050c9287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe a message handler.  <a href="#ga920fac8964a733d575dc83e7050c9287">More...</a><br /></td></tr>
<tr class="separator:ga920fac8964a733d575dc83e7050c9287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5e45f05d1fcdf446901f20426b5a6cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LcmC__lcm__t.html#gad5e45f05d1fcdf446901f20426b5a6cc">lcm_publish</a> (<a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *lcm, const char *channel, const void *data, unsigned int datalen)</td></tr>
<tr class="memdesc:gad5e45f05d1fcdf446901f20426b5a6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publish a message, specified as a raw byte buffer.  <a href="#gad5e45f05d1fcdf446901f20426b5a6cc">More...</a><br /></td></tr>
<tr class="separator:gad5e45f05d1fcdf446901f20426b5a6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga964c763e37b3c7f8af9ca37df381b10a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LcmC__lcm__t.html#ga964c763e37b3c7f8af9ca37df381b10a">lcm_handle</a> (<a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *lcm)</td></tr>
<tr class="memdesc:ga964c763e37b3c7f8af9ca37df381b10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for and dispatch the next incoming message.  <a href="#ga964c763e37b3c7f8af9ca37df381b10a">More...</a><br /></td></tr>
<tr class="separator:ga964c763e37b3c7f8af9ca37df381b10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48b225668d5c08264af47c7dd2ffb70f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LcmC__lcm__t.html#ga48b225668d5c08264af47c7dd2ffb70f">lcm_handle_timeout</a> (<a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *lcm, int timeout_millis)</td></tr>
<tr class="memdesc:ga48b225668d5c08264af47c7dd2ffb70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for and dispatch the next incoming message, up to a time limit.  <a href="#ga48b225668d5c08264af47c7dd2ffb70f">More...</a><br /></td></tr>
<tr class="separator:ga48b225668d5c08264af47c7dd2ffb70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga774831f6fa42ba3d6e6fae8a64f45b3a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LcmC__lcm__t.html#ga774831f6fa42ba3d6e6fae8a64f45b3a">lcm_subscription_set_queue_capacity</a> (<a class="el" href="group__LcmC__lcm__t.html#ga3149702f5022ed075e7aacb3bc261d00">lcm_subscription_t</a> *handler, int num_messages)</td></tr>
<tr class="memdesc:ga774831f6fa42ba3d6e6fae8a64f45b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the maximum number of received messages that can be queued up for a subscription.  <a href="#ga774831f6fa42ba3d6e6fae8a64f45b3a">More...</a><br /></td></tr>
<tr class="separator:ga774831f6fa42ba3d6e6fae8a64f45b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Publish and receive messages. </p>
<p>All LCM functions are internally synchronized and thread-safe.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;lcm/lcm.h&gt;</span></div>
</div><!-- fragment --><p>Linking: <code> <code>pkg-config --libs lcm</code> </code> </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga2cedfd752d27dc39c8ee0836993a3e53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* lcm_msg_handler_t) (const lcm_recv_buf_t *rbuf, const char *channel, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function prototype. </p>
<p>Pass instances of this to <a class="el" href="group__LcmC__lcm__t.html#ga1c8521ce6e87cbbeb7bfd935d5c0d724" title="Subscribe a callback function to a channel, without automatic message decoding. ">lcm_subscribe()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rbuf</td><td>the message timestamp and payload </td></tr>
    <tr><td class="paramname">channel</td><td>the channel the message was received on </td></tr>
    <tr><td class="paramname">user_data</td><td>the user-specified parameter passed to <a class="el" href="group__LcmC__lcm__t.html#ga1c8521ce6e87cbbeb7bfd935d5c0d724" title="Subscribe a callback function to a channel, without automatic message decoding. ">lcm_subscribe()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3149702f5022ed075e7aacb3bc261d00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _lcm_subscription_t <a class="el" href="group__LcmC__lcm__t.html#ga3149702f5022ed075e7aacb3bc261d00">lcm_subscription_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An opaque data structure that identifies an LCM subscription. </p>

</div>
</div>
<a class="anchor" id="gabb730c9e49442a4bcf400e0f2fef7576"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _lcm_t <a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opaque data structure containing the LCM context. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf29963ef43edadf45296d5ad82c18d4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a>* lcm_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>provider</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Allocates and initializes a lcm_t. provider must be either NULL, or a string of the form</p>
<p><code>"provider://network?option1=value1&amp;option2=value2&amp;...&amp;optionN=valueN"</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">provider</td><td>Initializationg string specifying the LCM network provider. If this is NULL, and the environment variable "LCM_DEFAULT_URL" is defined, then the environment variable is used instead. If this is NULL and the environment variable is not defined, then default settings are used.</td></tr>
  </table>
  </dd>
</dl>
<p>The currently supported providers are:</p>
<pre class="fragment">udpm://
    UDP Multicast provider
    network can be of the form "multicast_address:port".  Either the
    multicast address or the port may be ommitted for the default.

    options:
        recv_buf_size = N
            size of the kernel UDP receive buffer to request.  Defaults to
            operating system defaults

        ttl = N
            time to live of transmitted packets.  Default 0

    examples:
        "udpm://239.255.76.67:7667"
            Default initialization string

        "udpm://239.255.76.67:7667?ttl=1"
            Sets the multicast TTL to 1 so that packets published will enter
            the local network.
</pre><pre class="fragment">file://
    LCM Log file-based provider
    network should be the path to the log file

    Events are read from or written to the log file.  In read mode, events
    are generated from the log file in real-time, or at the rate specified
    by the speed option.  In write mode, events published to the LCM instance
    will be written to the log file in real-time.

    options:
        speed = N
            Scale factor controlling the playback speed of the log file.
            Defaults to 1.  If less than or equal to zero, then the events
            in the log file are played back as fast as possible.  Events are
            never skipped in read mode, so actual playback speed may be slower
            than requested, depending on the handlers.

        mode = r | w
            Specifies the log file mode.  Defaults to 'r'

        start_timestamp = USEC
            Seeks to USEC microseconds in the logfile, where USEC is given in
            microseconds since 00:00:00 UTC on 1 January 1970.  If USEC is
            before the first event, then playback begins at the start of the
            log file.  If it is after the last event, calls to lcm_handle will
            return -1.

    examples:
        "file:///home/albert/path/to/logfile"
            Loads the file "/home/albert/path/to/logfile" as an LCM event
            source.

        "file:///home/albert/path/to/logfile?speed=4"
            Loads the file "/home/albert/path/to/logfile" as an LCM event
            source.  Events are played back at 4x speed.</pre><pre class="fragment">memq://
   Memory queue test provider

   This provider is primarily useful for testing, especially unit testing code
   that uses LCM.  It provides a pub/sub interface that is private to the LCM
   instance, and does _not_ provide any interprocess communication, or even
   inter-instance communication.  Use this provider to implement unit tests
   that require deterministic and predictable behavior that is independent of
   a system's network configuration.

   example:
       "memq://"
           This is the only valid way to instantiate this provider.</pre><dl class="section return"><dt>Returns</dt><dd>a newly allocated lcm_t instance, or NULL on failure. Free with <a class="el" href="group__LcmC__lcm__t.html#ga4c86753e2e8c535bc8fb91d3763336e2" title="Destructor. ">lcm_destroy()</a> when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga51bd65da2efbd1ef094cb36b4a906922"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lcm_get_fileno </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *&#160;</td>
          <td class="paramname"><em>lcm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a file descriptor or socket that can be used with <code>select()</code>, <code>poll()</code>, or other event loops for asynchronous notification of incoming messages. </p>
<p>Each LCM instance has a file descriptor that can be used to asynchronously receive notification when incoming messages have been received. This file descriptor can typically be incorporated into an application event loop (e.g., GTK+, QT, etc.) For an example using select(), see examples/c/listener-async.c</p>
<dl class="section return"><dt>Returns</dt><dd>a file descriptor suitable for use with select, poll, etc. </dd></dl>

</div>
</div>
<a class="anchor" id="ga964c763e37b3c7f8af9ca37df381b10a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lcm_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *&#160;</td>
          <td class="paramname"><em>lcm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for and dispatch the next incoming message. </p>
<p>Message handlers are invoked one at a time from the thread that calls this function, and in the order that they were subscribed.</p>
<p>This function waits indefinitely. If you want timeout behavior, (e.g., wait 100ms for a message) then consider using <a class="el" href="group__LcmC__lcm__t.html#ga51bd65da2efbd1ef094cb36b4a906922" title="Returns a file descriptor or socket that can be used with select(), poll(), or other event loops for ...">lcm_get_fileno()</a> together with select() or poll()</p>
<p>Recursive calls to lcm_handle are not allowed &ndash; do not call lcm_handle from within a message handler. All other functions are okay (e.g., it is okay to call lcm_publish from within a message handler).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lcm</td><td>the LCM object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 normally, or -1 when an error has occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="ga48b225668d5c08264af47c7dd2ffb70f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lcm_handle_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *&#160;</td>
          <td class="paramname"><em>lcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_millis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for and dispatch the next incoming message, up to a time limit. </p>
<p>This function is equivalent to <a class="el" href="group__LcmC__lcm__t.html#ga964c763e37b3c7f8af9ca37df381b10a" title="Wait for and dispatch the next incoming message. ">lcm_handle()</a>, but if no messages are received and handled by the time <code>timeout_millis</code> milliseconds elapses, then the function returns.</p>
<p>This function largely exists for convenience, and its behavior can be replicated by using lcm_fileno() and <a class="el" href="group__LcmC__lcm__t.html#ga964c763e37b3c7f8af9ca37df381b10a" title="Wait for and dispatch the next incoming message. ">lcm_handle()</a> in conjunction with select() or poll().</p>
<p>New in LCM 1.1.0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lcm</td><td>the LCM object </td></tr>
    <tr><td class="paramname">timeout_millis</td><td>the maximum amount of time to wait for a message, in milliseconds. If 0, then dispatches any available messages and then returns immediately. Values less than 0 are not allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 if a message was handled, 0 if the function timed out, and &lt;0 if an error occured. </dd></dl>

</div>
</div>
<a class="anchor" id="gad5e45f05d1fcdf446901f20426b5a6cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lcm_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *&#160;</td>
          <td class="paramname"><em>lcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>datalen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publish a message, specified as a raw byte buffer. </p>
<p>In general, you probably don't want to use this function, as it does not automatically encode messages. Instead, use the message-specific publish function generated by <code>lcm-gen</code>. Use this function only when you want to publish raw byte buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lcm</td><td>The LCM object </td></tr>
    <tr><td class="paramname">channel</td><td>The channel to publish on </td></tr>
    <tr><td class="paramname">data</td><td>The raw byte buffer </td></tr>
    <tr><td class="paramname">datalen</td><td>Size of the byte buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1c8521ce6e87cbbeb7bfd935d5c0d724"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__LcmC__lcm__t.html#ga3149702f5022ed075e7aacb3bc261d00">lcm_subscription_t</a>* lcm_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *&#160;</td>
          <td class="paramname"><em>lcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__LcmC__lcm__t.html#ga2cedfd752d27dc39c8ee0836993a3e53">lcm_msg_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribe a callback function to a channel, without automatic message decoding. </p>
<p>In general, you probably don't want to use this function, as it does not automatically decode messages. Instead, use the message-specific subscribe function generated by <code>lcm-gen</code>. Use this function only when you want to work with the raw message itself. TODO link to example or more details.</p>
<p>The callback function will be invoked during calls to <a class="el" href="group__LcmC__lcm__t.html#ga964c763e37b3c7f8af9ca37df381b10a" title="Wait for and dispatch the next incoming message. ">lcm_handle()</a> any time a message on the specified channel is received. Multiple callbacks can be subscribed for the same channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lcm</td><td>the LCM object </td></tr>
    <tr><td class="paramname">channel</td><td>the channel to listen on. This can also be a GLib regular expression, and is treated as a regex implicitly surrounded by '^' and '$' </td></tr>
    <tr><td class="paramname">handler</td><td>the callback function to be invoked when a message is received on the specified channel </td></tr>
    <tr><td class="paramname">userdata</td><td>this will be passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a lcm_subscription_t to identify the new subscription, which can be passed to <a class="el" href="group__LcmC__lcm__t.html#ga920fac8964a733d575dc83e7050c9287" title="Unsubscribe a message handler. ">lcm_unsubscribe()</a>. The lcm_t instance owns the subscription object. </dd></dl>

</div>
</div>
<a class="anchor" id="ga774831f6fa42ba3d6e6fae8a64f45b3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lcm_subscription_set_queue_capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__LcmC__lcm__t.html#ga3149702f5022ed075e7aacb3bc261d00">lcm_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_messages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjusts the maximum number of received messages that can be queued up for a subscription. </p>
<p>In general, you probably don't want to use this function. Instead, use the message-specific set_queue_capacity function generated by <code>lcm-gen</code>. Use this function only when you want to work with untyped subscriptions. TODO link to example or more details.</p>
<p>Setting this to a low number may reduce overall latency at the expense of dropping more messages. Conversely, setting this to a high number may drop fewer messages at the expense of increased latency. A value of 0 indicates no limit, and should be used carefully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>the subscription object </td></tr>
    <tr><td class="paramname">num_messages</td><td>the maximum queue size, in messages. The default is 30. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga920fac8964a733d575dc83e7050c9287"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lcm_unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *&#160;</td>
          <td class="paramname"><em>lcm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__LcmC__lcm__t.html#ga3149702f5022ed075e7aacb3bc261d00">lcm_subscription_t</a> *&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsubscribe a message handler. </p>
<p>In general, you probably don't want to use this function. Instead, use the message-specific unsubscribe function generated by <code>lcm-gen</code>. Use this function only when you want to work with the raw message itself. TODO link to example or more details.</p>
<p>The callback function for the subscription will no longer be invoked when messages on the corresponding channel are received. After this function returns, <code>handler</code> is no longer valid and should not be used anymore.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or -1 if <code>handler</code> is not a valid subscription. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr class="footer"/></body>
</html>
