<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LCM: CMake Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LCM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">CMake Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Generating LCM type bindings with CMake</p>
<p>This tutorial will walk you through writing a <code>CMakeLists.txt</code> to generate bindings for your LCM message types. Please note that this is <em>not</em> meant to serve as a general CMake tutorial. This tutorial assumes that you are already familiar with CMake.</p>
<dl class="section note"><dt>Note</dt><dd>This tutorial assumes that you are using CMake 3.1 or later. Some of the features used, especially those related to the creation of a convenient <code>INTERFACE</code> library for C++ bindings, are not available in older versions of CMake. If you are using an older version of CMake, you may need to refer to the implementation details of LCM's helper functions, found in <code>lcmUtilities.cmake</code>, in order to manually accomplish the tasks that the helper functions would normally do. Note that <em>all</em> of the helper functions require CMake 3.1 or later on Windows, and that it is much more difficult to use <code>lcm-gen</code> on Windows from within CMake prior to CMake 3.1.</dd></dl>
<h3>Initial Setup</h3>
<p>The very first thing you'll want to do is to find LCM and include its "use
file". (A "use file" is a CMake script provided with some packages that adds utility functions for using that package. Many, including LCM's, provide additional documentation of their utility functions in the use file itself.) Depending on how you will be using LCM, as well as personal preference, this can be done in your project's root <code>CMakeLists.txt</code>. This is also a good time to look for additional language components you may want, such as Python and Java. (If you will not need bindings for these languages, you can omit those parts. Alternatively, you may want to make them <code>REQUIRED</code>.) </p><pre class="fragment">find_package(lcm REQUIRED)
include(${LCM_USE_FILE})

find_package(PythonInterp)
find_package(Java)

if(JAVA_FOUND)
  include(UseJava)
endif()
</pre><p>The rest of the CMake logic we will show will typically go in the <code>CMakeLists.txt</code> that is located with your LCM type files.</p>
<h3>A Simple Example</h3>
<p>We'll start with a very simple example that generates a <code>STATIC</code> library of C language bindings: </p><pre class="fragment">lcm_wrap_types(
  C_SOURCES c_sources
  C_HEADERS c_headers
  my_type_1.lcm
  my_type_2.lcm
  ...
)

lcm_add_library(my_lcmtypes C STATIC ${c_sources} ${c_headers})
target_include_directories(my_lcmtypes INTERFACE
  $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}&gt;)
</pre><p>The first function creates rules to invoke <code>lcm-gen</code> to generate the binding source files. The names <code>c_sources</code> and <code>c_headers</code> are the names of variables that will receive these lists of files. You can see where we use them again to create the C library. We chose these names as they are both simple and clear, but you can use whatever names you like.</p>
<p>The second function creates a C library, which is <code>STATIC</code>, from the specified sources. Including the header files is optional, but may be beneficial to some IDE's. This has a couple advantages over plain old <code>add_library</code>. First, it will link the library to LCM for you. Second, and more important, it will set up an additional target to ensure that all of the named bindings have been generated before the sources are compiled. This is important for some generators when one LCM type references another; otherwise, the build tool might try to compile the source file for one type before the header for the referenced type has been generated, resulting in a spurious build error.</p>
<p>Before we call it a day, it would be nice if consumers could find the library's headers. We do that by adding an interface include directory, like so: </p><pre class="fragment">target_link_libraries(my_lcmtypes INTERFACE
  $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}&gt;)
</pre><p>Note the use of <code>$&lt;BUILD_INTERFACE&gt;</code> to tell CMake that the include directory should not be included in the installed version of the library. This prevents details of your build from leaking into the install. We'll handle the include directory for the installed library differently. (If there are no local consumers of your library, you can skip this step.)</p>
<p>The include directory should be the directory where the bindings are generated. Since we didn't pass a <code>DESTINATION</code> to <code>lcm_wrap_types</code>, it defaulted to the current subdirectory of the build tree (<code>CMAKE_CURRENT_BINARY_DIR</code>).</p>
<h3>Shared C Libraries</h3>
<p>Static libraries are ugly. They inflate the size of every binary that consumes them, and they can't be replaced with updated versions without recompiling every consumer.</p>
<p>Of course, as you probably know, creating a shared library on Windows, or if using ELF hidden symbol visibility (which you really, really should be doing), requires a) marking those parts of your API that should be exported, and b) specifying how to mark an exported function. You've almost certainly seen headers peppered with preprocessor symbols like <code>LCM_EXPORT</code>, and you probably know that the correct definition of such symbols depends on both the platform and whether you are building or consuming the library.</p>
<p>Fortunately, <code>lcm-gen</code> can take care of the first item for you with only a very little hand-holding, and as you probably already know, CMake has an excellent utility, <a href="https://cmake.org/cmake/help/v3.1/module/GenerateExportHeader.html"><code>generate_export_header</code></a>, for the second. Let's update our example to use them: </p><pre class="fragment">lcm_wrap_types(
  C_EXPORT my_lcmtypes
  C_SOURCES c_sources
  C_HEADERS c_headers
  my_type_1.lcm
  my_type_2.lcm
  ...
)

lcm_add_library(my_lcmtypes C ${c_sources} ${c_headers})
generate_export_header(my_lcmtypes)
target_include_directories(my_lcmtypes INTERFACE
  $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}&gt;)
</pre><p>Note the addition of <code>C_EXPORT</code> to our invocation of <code>lcm_wrap_types</code>. This is designed to work with <code>generate_export_header</code>, and will specify both the symbol name and export header name as created by <code>generate_export_header</code>. In this instance, we are using the library name, but you can use whatever you like by passing the same name to <code>C_EXPORT</code> (<code>lcm_wrap_types</code>) and <code>BASE_NAME</code> (<code>generate_export_header</code>).</p>
<p>Note also that we didn't replace <code>STATIC</code> with <code>SHARED</code>, but rather just removed it. Just like a regular call to <code>add_library</code>, this will generate a library that is either static or shared depending on if <code>BUILD_SHARED_LIBS</code> is enabled. This approach is often preferred as it allows the user to decide if they want static libraries or shared libraries, but you can also use <code>SHARED</code> to enforce building of a shared library.</p>
<h3>C++</h3>
<p>We probably want to generate at least C++ bindings also. Let's do that now: </p><pre class="fragment">lcm_wrap_types(
  C_EXPORT my_lcmtypes
  C_SOURCES c_sources
  C_HEADERS c_headers
  CPP_HEADERS cpp_headers
  my_type_1.lcm
  my_type_2.lcm
  ...
)

# ...logic for C library...

lcm_add_library(my_lcmtypes-cpp CPP ${cpp_headers})
target_include_directories(my_lcmtypes-cpp INTERFACE
  $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}&gt;)
</pre><p>None of this should look surprising after seeing how the C library was created. The additional argument to <code>lcm_wrap_types</code>, <code>CPP_HEADERS</code>, serves both to tell <code>lcm_wrap_types</code> to generate C++ bindings, and what variable should receive the list of C++ headers. <code>C_SOURCES</code> and <code>C_HEADERS</code> work very much the same way; by omitting both, we can skip generation of C bindings. (Unlike <code>CPP_HEADERS</code>, <code>C_SOURCES</code> and <code>C_HEADERS</code> are coupled; it is an error to specify one without the other.)</p>
<p>"But wait," you may be thinking to yourself, "aren't LCM C++ bindings header
only?" Indeed they are, which is why this "library" is really an <code>INTERFACE</code> library. An <code>INTERFACE</code> library in CMake is just a fancy way of hanging usage requirements (like the <code>target_include_directories</code>, above) off of a target so that consumers can consume a logical target with the same convenience that they can consume targets that have actually binary objects backing them.</p>
<p>There is one critical caveat to this, however. Just like our C library needed to ensure that the bindings are generated before the sources are built, consumers of the C++ bindings need to ensure that the bindings are actually built before the consumer.</p>
<p>CMake 3.3 added the ability to hang dependencies off of <code>INTERFACE</code> libraries, and <code>lcm_add_library</code> will do this for you for the C++ library just as for the C library. Earlier versions of CMake lack this wonderfully convenient feature, but fortunately, LCM can help us out. If your project might be build with CMake earlier than 3.3, using <code>lcm_target_link_libraries</code> when linking a consumer to a C++ bindings library such as shown above will automagically set up a dependency to ensure that the bindings are generated before trying to build the consumer. Just use <code>lcm_target_link_libraries</code> with the same arguments as you would use <code>target_link_libraries</code>. (If your project enforces use of CMake 3.3 or later, or if the bindings you are consuming are build by an external project, just use <code>target_link_libraries</code>.)</p>
<h3>Python and Java</h3>
<p>C and C++ are great, but you may well have users that want to consume your LCM types with Python or Java. Just as when we added C++, we'll start by adding some additional arguments to <code>lcm_wrap_types</code>. Depending on whether you generate these bindings always, or opportunistically when Python and/or Java are available, you may want to make this logic conditional, as in the approach shown here: </p><pre class="fragment">if(PYTHONINTERP_FOUND)
  set(python_args PYTHON_SOURCES python_sources)
endif()
if(JAVA_FOUND)
  set(java_args JAVA_SOURCES java_sources)
endif()

lcm_wrap_types(
  C_EXPORT my_lcmtypes
  C_SOURCES c_sources
  C_HEADERS c_headers
  CPP_HEADERS cpp_headers
  ${python_args}
  ${java_args}
  my_type_1.lcm
  my_type_2.lcm
  ...
)
</pre><p>If you require Python and/or Java, you can of course simply inline the corresponding arguments as is done for C and C++. Note that the main reason to require that Python is found is so that we can match its version in order to install things to the right place. If you have some other means of determining the correct install location, you could skip requiring that Python is found.</p>
<p>Python doesn't need to "build" anything (and we'll come back to installation in a moment), so for now, the only other change is to build the JAR: </p><pre class="fragment">if(JAVA_FOUND)
  add_jar(my_lcmtypes-jar
    OUTPUT_NAME my_lcmtypes
    INCLUDE_JARS lcm-java
    SOURCES ${java_sources}
  )
endif()
</pre><p>As before, if you require Java, you can omit the <code>JAVA_FOUND</code> check.</p>
<h3>Installing Everything</h3>
<p>First, let's revisit our variable names: </p><pre class="fragment">if(PYTHONINTERP_FOUND)
  set(python_args PYTHON_SOURCES python_install_sources)
endif()
if(JAVA_FOUND)
  set(java_args JAVA_SOURCES java_sources)
endif()

lcm_wrap_types(
  C_EXPORT my_lcmtypes
  C_SOURCES c_sources
  C_HEADERS c_install_headers
  CPP_HEADERS cpp_install_headers
  ${python_args}
  ${java_args}
  my_type_1.lcm
  my_type_2.lcm
  ...
)
</pre><p>Note that we've added <code>_install_</code> to a few of the variable names. While this is in no way necessary (recall that the variable names can be whatever you like), it serves to clearly indicate which variables hold the names of files that need to be installed, and which are only files to be compiled.</p>
<p>We'll skip repeating the rest of the existing logic, but don't forget to change the names of these variables in the other locations they appear.</p>
<p>Now, we'll install everything: </p><pre class="fragment">lcm_install_headers(DESTINATION include
  ${CMAKE_CURRENT_BINARY_DIR}/my_lcmtypes_export.h
  ${c_install_headers}
  ${cpp_install_headers}
)

if(PYTHONINTERP_FOUND)
  lcm_install_python(${python_install_sources})
endif()

install(TARGETS my_lcmtypes my_lcmtypes-cpp
  EXPORT ${PROJECT_NAME}Targets
  RUNTIME DESTINATION bin
  LIBRARY DESTINATION lib${LIB_SUFFIX}
  ARCHIVE DESTINATION lib${LIB_SUFFIX}
  INCLUDES DESTINATION include
)

if(JAVA_FOUND)
  install_jar(my_lcmtypes-jar share/java)
endif()
</pre><p>The two LCM-provided helper functions we used here, <code>lcm_install_headers</code> and <code>lcm_install_python</code>, are convenience functions that will preserve subdirectory components (particularly, the package name subdirectory of the C++ headers) of the files being installed. Additionally, <code>lcm_install_python</code> chooses the correct destination directory by default. We also use <code>INCLUDES DESTINATION</code> when installing the libraries to set the interface include directories on the libraries. This directory should match the <code>DESTINATION</code> to which the headers are installed.</p>
<p>Note that we specified an <code>EXPORT</code> for the C/C++ libraries, but do not show installing the target exports file or creating build-tree exports. This is because these procedures a) are not specific to LCM, and b) must be done in a single location for the entire project. For similar reasons, we also did not show exporting the JAR file. (LCM itself may be used as an example of these tasks.)</p>
<p>Note that exporting JAR files requires CMake 3.7 or later, or copying <code>UseJava.cmake</code> into your project. See LCM itself for an example of the latter. (Note that <em>consumers</em> of exported JAR's don't require CMake 3.7; the created export files are perfectly usable with much older versions of CMake.)</p>
<h3>Other Useful Tidbits</h3>
<p>We did not cover every possible argument to <code>lcm_wrap_types</code>. Most of the options accepted by <code>lcm-gen</code> are available through <code>lcm_wrap_types</code>. See <code>lcmUtilities.cmake</code> and <code>lcm-gen --help</code> for more information on what options are available. </p>
</div></div><!-- contents -->
<hr class="footer"/></body>
</html>
