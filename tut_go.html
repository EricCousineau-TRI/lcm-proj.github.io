<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LCM: Go Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LCM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Go Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Sending and receiving LCM messages using Go</p>
<h1><a class="anchor" id="tut_go_intro"></a>
Introduction</h1>
<p>This tutorial will walk you through the main tasks for exchanging LCM messages using the Go LCM library. Throughout this tutorial, we will look at how to:</p>
<ul>
<li>Initialize an LCM instance. </li>
<li>Publish a message. </li>
<li>Subscribe to a channel and receive a message over it.</li>
</ul>
<p>Like the other tutorials, this one uses the <code>example_t</code> message type defined in the <a class="el" href="tut_lcmgen.html">type definition tutorial</a>, and assumes that you have generated the Go bindings by executing for it:</p>
<div class="fragment"><div class="line">cd examples/go</div><div class="line">go generate</div></div><!-- fragment --><p>This should produce a few go files in <code>exlcm</code>, we will use the file called <code>exlcm/example_t.go</code>.</p>
<p>The file contains everything you need to encode and decode data of type example_t, which is necessary in order to use LCM.</p>
<h1><a class="anchor" id="tut_go_initialize"></a>
Initializing LCM</h1>
<p>That was not too difficult, right? Time to actually get our hands dirty with some actual Go code.</p>
<p>The first thing that you will need to do, is to fetch the actual library. You can use <code>go get</code> or any other dependency manager of your choice: <code>go get github.com/lcm-proj/lcm/lcm-go/lcm</code></p>
<p>After you have successfully executed that, you are able to use and import the just fetched library. Make sure that the following code is inside a subdirectory of <code>$GOPATH/src</code>.</p>
<div class="fragment"><div class="line">package main</div><div class="line"></div><div class="line">import &quot;github.com/lcm-proj/lcm/lcm-go/lcm&quot;</div><div class="line"></div><div class="line">func main() {</div><div class="line">    lc, err := lcm.New()</div><div class="line">    if err != nil {</div><div class="line">        panic(err)</div><div class="line">    }</div><div class="line">    defer lc.Destroy()</div><div class="line">}</div></div><!-- fragment --><p>This will result in a new lcm instance by the name <code>lc</code> that is ready for use.</p>
<p>As we are dealing with Go bindings towards the C library, it is quite easy to use. Maybe even easier than the C library itself. <code>lc</code> contains all the methods that you will need to utilize LCM based communication.</p>
<p>Compile and run the code to see, if it works: <code>go run path/to/subdirectory</code></p>
<p>As you can see, we are also using <code>defer</code> to destroy the LCM instance just right before main is done executing.</p>
<h1><a class="anchor" id="tut_go_publish"></a>
Publishing a message</h1>
<p>Now that you have successfully created an LCM instance in Go, it is time to actually send some data to a channel. This is done by sending data down a Golang channel that the <code>Publisher(string)</code> method of the instance that we just created returns.</p>
<p>The passed string is the channel's name that you want to send the data to. Alongside the actual Go channel that you can send the data to, another channel is returned. This is an error channel that you have to check for any errors that could potentially occur.</p>
<p>Finally, make sure that you are actually sending (LCM) encoded data down the channel. So where do you get that from? <em>From the Go bindings that you have generated earlier!</em></p>
<div class="fragment"><div class="line">    // Skipping the code above...</div><div class="line">    // Create a pointer to a new ExampleT object.</div><div class="line">    example := &amp;exlcm.ExampleT{}</div><div class="line"></div><div class="line">    publisher, errs := lc.Publisher(&quot;EXAMPLE&quot;)</div><div class="line"></div><div class="line">    go func() {</div><div class="line">        defer close(publisher)</div><div class="line"></div><div class="line">        // Let&#39;s send that a couple of times</div><div class="line">        for i := 0; i &lt; 100; i++ {            </div><div class="line">            // Encode the data.</div><div class="line">            encEx, err := example.Encode()</div><div class="line">            if err != nil {</div><div class="line">                panic(err)</div><div class="line">            }</div><div class="line"></div><div class="line">            // Send down a channel.</div><div class="line">            publisher &lt;- encEx</div><div class="line">        }</div><div class="line">    }()</div><div class="line"></div><div class="line">FOR_SELECT:</div><div class="line">    for {</div><div class="line">        select {</div><div class="line">            err, ok := &lt;- errs:</div><div class="line">            if !ok {</div><div class="line">                break FOR_SELECT</div><div class="line">            }</div><div class="line">            panic(err)</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>As you can see, it does not require much code to send something through LCM using Go. Obviously, in a real-world case, one would need to initialize <code>example</code> with appropriate values, instead of initializing everything to default values.</p>
<p>An important note: as soon as you are done with sending to a channel, you should close the corresponding publisher channel, as we are doing in the <code>defer</code> statement. This is necessary, so that you do not end up in a potential deadlock. The errs channel is only closed <em>after</em> the publisher one is.</p>
<h1><a class="anchor" id="tut_go_receive"></a>
Receiving LCM Messages</h1>
<p>Receiving messages is just as simple as sending them out. It's just the other way around. Needless to say, it is important that the sender and receiver "know" about the channel that is used for communication. Therefore, we will also use the channel called <b>EXAMPLE</b> that we used earlier to send out information, as the receiving channel.</p>
<p>In order to receive data, you will need to check for data that comes down a Go channel. Usually, deserialize the received data back into a suitable object is a reasonable way to do here.</p>
<div class="fragment"><div class="line">    // Skipping the code from the initialization part.</div><div class="line">    // Subscribe to the previously used EXAMPLE channel. The subscription Go</div><div class="line">    // channel has a buffer size 5, whenever more messages are pending than the</div><div class="line">    // buffer size they are dropped.</div><div class="line">    if subscription, err := lc.Subscribe(&quot;EXAMPLE&quot;, 5); if err != nil {</div><div class="line">        panic(err)</div><div class="line">    }</div><div class="line">    // Not explicitly necessary, as Destroy() also unsubscribes to all</div><div class="line">    // subscriptions.</div><div class="line">    defer lc.Unsubscribe(subscription)</div><div class="line"></div><div class="line">FOR:</div><div class="line">    for {</div><div class="line">        select {</div><div class="line">        // Usually you have a timeout to not deadlock.</div><div class="line">        case &lt;-time.After(5 * time.Second):</div><div class="line">            break FOR</div><div class="line"></div><div class="line">        case data, ok := &lt;- subscription.ReceiveChan:</div><div class="line">            if !ok {</div><div class="line">                // That means that the channel was closed.</div><div class="line">                break FOR</div><div class="line">            }</div><div class="line">            fmt.Println(&quot;Received information on&quot;, channel)</div><div class="line"></div><div class="line">            // Empty example_t</div><div class="line">            exType := &amp;exlcm.ExampleT{}</div><div class="line"></div><div class="line">            // Decode the received data</div><div class="line">            if err := exType.Decode(data); err != nil {</div><div class="line">                panic(err)</div><div class="line">            }</div><div class="line"></div><div class="line">            // Simple print out of the whole object.</div><div class="line">            fmt.Println(exType)</div><div class="line"></div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>Done!</p>
<p>As you can see, we are also unsubscribing right before we are done. This is only possible because we are timing out (and returning) after five seconds. ReceiveChan is only closed whenever one unsubscribes. Therefore:: <b>be aware of potential deadlocks that you could introduce to your application</b>.</p>
<h1><a class="anchor" id="tu_go_concl"></a>
Conclusion and Important Information</h1>
<p>Obviously, this tutorial outlines just a really simple use-case of LCM in Go. Some of the practices used here ought to be avoided in a proper production application (such as the use of panic for error handling).</p>
<p>Throughout the tutorial you might have noticed that the original type name which was called <code>example_t</code> got transferred into something like <code>ExampleT</code>. This is was an actively chosen design decision. As it is Go best-practice to use Camel-Casing, every _ will be removed and the following character will be capitalized. Furthermore, the casing describes if a member or function gets exported or not in Go: capitalized member/function name = exported function; small-cased member/function name = unexported function. Therefore, every type gets automatically capitalized by the code generator.</p>
<p>You can find more complete and compilable executables here: <a href="https://github.com/lcm-proj/lcm/blob/master/examples/go/listener/main.go">listener/main.go</a> | <a href="https://github.com/lcm-proj/lcm/blob/master/examples/go/sender/main.go">sender/main.go</a></p>
<p>If you need more information about the language itself, you should check out <a href="https://golang.org/">the official Go web pages</a>, which are usually of great help. </p>
</div></div><!-- contents -->
<hr class="footer"/></body>
</html>
